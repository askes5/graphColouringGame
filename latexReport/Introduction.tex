\chapter{Introduction}\label{chpt:into}
%todo what is a graph
A graph, denoted $G$, is a set of vertices, $V(G)$, and edges, $E(G)$. Where the set of edges defines a relation on $V(G)$, and are represented as pairs of vertices. For example in figure \ref{fig:k3} we have three edges $(a,b)$, $(a,c)$, and $(b,c)$. There are two main types of graphs we consider, directed graphs where the direction of the edge matters ($(a,b)\neq (b,a)$) and undirected graphs where the direction doesn't matter ($(a,b)=(b,a)$). 

\begin{figure}[h]
    \centering
\begin{tikzpicture}[scale=2]
\node[normal, label=below:$a$] (v1) at (-1.5,-1) {};
\node[normal, label=below:$b$] (v3) at (-0.5,-1) {};
\node[normal, label=below:$c$] (v2) at (-1,0) {};  
\draw (v1) edge (v2);
\draw  (v2) edge (v3);
\draw  (v3) edge (v1);
\end{tikzpicture}
    \caption{An undirected graph with three vertices and three edges}
\label{fig:k3}
\end{figure}
   
%ubiqity of graphs 
Graphs are everywhere. Though they may not be immediately apparent. 
Graphs help us understand data and structures in a way that is easier to visualise and analyse. An example from recent events is COVID--19, and more generally infectious diseases.  Suppose we are in charge of contact tracing a small country. And we have a list of all the people who have contracted COVID-19. We can build a graph by considering infected people as vertices in the graph. We join two people with an edge if the disease spread between them. %todo insert picture of spread
From such a graph we can easily determine things like, who is the most infectious (who has the most infected neighbours), and where is community transmission occurring (a piece of the graph that is disconnected from the rest represents a cluster).
     
%graph algorithms   
A graph algorithm is a set of instructions that define some procedure on a graph. An algorithm can be as simple as finding a certain vertex. Or can be as complicated as colouring all the vertices using only a finite number of colours.  

Suppose we are charged with laying fibre optic cable in a neighbourhood. Our goal is to use the least amount of cable possible while still connecting all the houses. We can form a graph with the houses as vertices and an edge between two houses if it is possible to lay cable between them. We then label each edge with a number representing the cost of laying cable between the two houses. The first step is to lay cable at the edge with the lowest cost. Next we lay cable at the edge with the least cost such that laying cable at this edge will not introduce a cycle (a closed path) of cable. By repeating this last step eventually we will have laid cable that connects all the houses. Further the cable we laid will have the least possible cost. These steps are an example of a graph algorithm.
   
We introduce the idea of a graph game by considering the \textit{Dinner Party Problem}.
Suppose Alice is hosting a party and all the guests are mingling happily. However, the guests are hungry and need to be feed. But they are lazy will not move to collect food. When serving, food platters are placed around the room near the guests. A guest will take some food if a platter is placed within arm's reach. Alice needs to place platters in such a way that every guest can reach a platter. The food is expensive. So Alice wants to place the smallest number of platters possible. The problem is then, what is the minimum number of platters that Alice needs to feed everybody? 

%To see this, we can define a graph, $G$, with guests as vertices and an edge between two guests if when either of them are given a platter they will pass food between them. Minimising the number platters is now a matter of finding a set of vertices, $D$ in $G$ such that every vertex in $V(G)$ is incident to some vertex in $D$.

After the success of the first party, Alice decides to host another party. To alleviate the pressure of hosting she decides to hire a caterer, Bob. As before the platters are placed around the room. A guest will take some food if there is a platter within arms reach. Staring with Alice and on alternating turns Alice and Bob place a single platter. This continues until all the guests have been feed. As before Alice tries to use the smallest number of platters possible. Bob on the other hand makes a profit for every platter and so will try to place as many platters as possible. Bob is being paid by Alice. So, every platter he places must feed at least one new person. If not then Alice would fire Bob.
If Bob was to always place a platter such that it would feed the least number of people then the total number of platters placed would be greater than the first party. Hence, Alice requires some strategy to minimise the number platters placed. The Dinner Party Problem is then, what is the smallest number of platters that Alice can guarantee will always feed everyone? 
%If we define a graph as in the first party, finding a minimum number of platters is a matter of finding an optimal strategy for Alice to hand out a minimum number of platters. 
We further explore this idea in the context of the domination game and the game domination number in Chapter \ref{chpt:domSet}.

It is easy to see how this concept could be applied to other situations. For example, in wartime a nation may be trying to destroy railroads, using the minimum number bombs possible, but their allies are secretly colluding with the enemy. Such an ally would try to make it as costly as possible to destroy railroads. Other Examples include a measure of robustness in network infrastructure, scheduling, and register allocation.  

In this report %todo report?
we explore four different graph games with hostile partners. These are,
\begin{enumerate}
    \item Dominating game: \\
        Alice and Bob take turns building a dominating set.
    \item Independent dominating game: \\
        Alice and Bob take turns building a maximal independent set    
    \item Colouring Game: \\
        Alice and Bob take turns colouring a graph.
    \item Marking Game: \\
        Alice and Bob take turns ordering the vertices of a graph.
\end{enumerate}

In chapter \ref{chpt:domSet} we will explore the dominating and the independent dominating games. To begin we  will formally define the dominating game. We will introduce upper and lower bounds for some classes of graphs. To bound these classes we will provide some explicit strategies for Alice. We will then extend the game to allow Alice and Bob to play more than once per turn. Finally, we will consider some bounds in the independent dominating game.

In chapter \ref{chpt:colouring} we will explore the colouring and marking games. We will begin with the standard colouring game. This game will then be extended to a version where Alice and Bob play more than once per turn. We will provide lower bounds for the colouring game. The marking game will then be introduced as a way to bound the colouring game. To do this we will uses the activation strategy. We will conclude with a look at the current best bound for the class of planer graphs.

%todo why is this iteresting, applications

%todo What this this report about

%todo where has this come from

%This work has many applications in computer science and operations research, including flight scheduling, bandwidth allocation and register allocation, as well as deep theoretical interest%note this is plagrisum
    
A note on notation. If $\CC$ is a class of graphs, and $\varphi_g(G)$ some property of a graph $G \in \CC$. Then $\varphi_g(\CC)$ is the smallest $k$ such that for every graph $H\in\CC$ $\varphi_g(H)\leq k$. A class $\CC$ is bounded above by $k$ if for every graph $H\in\CC$ $\varphi_g(H)\leq k$. $\CC$ is bounded below by $k$ if there is a graph $H$ in $\CC$ such that $\varphi_g(H)= k$. This can be thought of as Bob being allowed to pick the graph. If the game has a target score $t$ then Bob will win if $t < \varPhi_g(G)$. So, if he is allowed to pick the graph he will pick a graph $G$ with $\varPhi_g(G) > t$. Then if $t\geq \varPhi_g(G)$ then tt would not matter what graph Bob picks. Alice will always win. When considering a graph game we always consider it to be played by two player Alice and Bob.  

Finally, we introduce some game terms. In a game whenever Alice or Bob has there turn by choosing a vertex we call this a \textit{play}. For example in the colouring game a play when Alice chooses a vertex and assigns it a colour. A \textit{round} is a play of both Alice and Bob.  %todo terms and definations
   %todo class of graphs?


%todo add summery of results
    
%todo basic notation?
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    