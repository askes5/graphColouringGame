\chapter{Introduction}\label{chpt:into}

\section{Graphs}
A graph, $G=(V,E)$, is a pair of vertices, $V(G)$, and edges, $E(G)$. The set of edges forms a relation on the vertices. The individual edges are represented as pairs of vertices. For example in figure \ref{fig:k3} we have three edges $(a,b)$, $(a,c)$, and $(b,c)$. There are two main types of graphs we consider, directed graphs where the direction of the edge matters ($(a,b)\neq (b,a)$) and undirected graphs where the direction doesn't matter ($(a,b)=(b,a)$). 

\begin{figure}[h]
    \centering
\begin{tikzpicture}[scale=2]
\node[normal, label=below:$a$] (v1) at (-1.5,-1) {};
\node[normal, label=below:$b$] (v3) at (-0.5,-1) {};
\node[normal, label=below:$c$] (v2) at (-1,0) {};  
\draw (v1) edge (v2);
\draw  (v2) edge (v3);
\draw  (v3) edge (v1);
\end{tikzpicture}
    \caption{An undirected graph with three vertices and three edges}
\label{fig:k3}
\end{figure}
   
%ubiqity of graphs 
Graphs are abstract representations of relationship between objects. They do this in a way that is easier to visualise and analyse. An example from recent events is COVID--19, and more generally infectious diseases.  Suppose we are in charge of monitoring an outbreak small country. We have a list of all the people who have contracted COVID-19. We consider a graph by representing people as vertices in the graph. We join two people with an edge if the disease could spread between them.
Then by colouring infected vertices we can easily visualise things like, who is the most infectious (who has the most infected neighbours), and where is community transmission occurring (a group of infections that are disconnected from the rest of the infections).
  
\section{Graph Algorithms}
%graph algorithms   
A graph algorithm is a set of instructions that define some procedure on a graph. An algorithm can be as simple as finding a vertex of even degree. Or more complicated, as when colouring all the vertices using only a finite number of colours.  

Suppose we are charged with laying fibre optic cable in a neighbourhood. Our goal is to use the least amount of cable possible while still connecting all the houses. We can use a graph to model the relation between houess. The houses form the vertices and there is edge between two houses if it is possible to lay cable between them.
It costs different amounts to lay cable between different houses. This is because some houses are further apart, have water between them, require more digging, etc. 
We associate each edge with a number representing the cost of laying cable between the two houses. This forms what is known as a \textit{weighted graph}. We now have all the information need to lay cable. The first step is to lay cable between the houses at the edge with the lowest cost. Next we lay cable between the houses at the edge with the least cost such that laying cable at this edge will not introduce a cycle (a closed path) of cable. By repeating this last step eventually we will have laid cable that connects all the houses. Further the cable we laid will have the least possible cost. These steps are an example of a graph algorithm. This particular algorithm is called \textit{Kruskal's algorithm}. 
 
 \section{Graph Games}  
We introduce the idea of a graph game by considering two related problems, the \textit{Dinner Party Problem} and the \textit{Dinner Party Game Problem}.

Suppose Alice is hosting a party and all the guests are mingling happily. However, the guests are hungry and need to be feed. But they are lazy will not move to collect food. When serving, food platters are placed around the room near the guests. A guest will take some food if a platter is placed within arm's reach. Alice needs to place platters in such a way that every guest can reach a platter. The food is expensive. So, Alice wants to place the smallest number of platters possible. The dinner party problem is, what is the minimum number of platters that Alice needs to feed everybody? 

%To see this, we can define a graph, $G$, with guests as vertices and an edge between two guests if when either of them are given a platter they will pass food between them. Minimising the number platters is now a matter of finding a set of vertices, $D$ in $G$ such that every vertex in $V(G)$ is incident to some vertex in $D$.

After the success of the first party, Alice decides to host another party. To alleviate the pressure of hosting she decides to hire a caterer, Bob. As before the platters are placed around the room. A guest will take some food if there is a platter within arms reach. Staring with Alice and on alternating turns Alice and Bob place a single platter. This continues until all the guests have can be feed. As before Alice tries to use the smallest number of platters possible. Bob on the other hand makes a profit for every platter and so will try to place as many platters as possible. Bob is being paid by Alice. So, every platter he places must feed at least one new person. If not then Alice would fire Bob. If Bob was to always place a platter such that it would feed the least number of people then the total number of platters placed would be greater than the first party. Hence, Alice requires some strategy to minimise the number platters placed. The Dinner Party Game Problem is then, what is the smallest number of platters that Alice can guarantee will always feed everyone? 
%If we define a graph as in the first party, finding a minimum number of platters is a matter of finding an optimal strategy for Alice to hand out a minimum number of platters. 
We further explore this idea in the context of the domination game and the game domination number in Chapter \ref{chpt:domSet}.

It is easy to see how this concept could be applied to other situations. For example, in wartime a nation may be trying to destroy railroads, using the minimum number bombs possible, but their allies are secretly colluding with the enemy. Such an ally would try to make it as costly as possible to destroy railroads. Other Examples include a measure of robustness in network infrastructure, scheduling, and register allocation.  

In this report %todo report?
we will explore four different graph games with hostile partners. These are,
\begin{itemize}
    \item Dominating game: \\
        Alice and Bob take turns building a dominating set.
    \item Independent dominating game: \\
        Alice and Bob take turns building a maximal independent set    
    \item Colouring Game: \\
        Alice and Bob take turns colouring a graph.
    \item Marking Game: \\
        Alice and Bob take turns ordering the vertices of a graph.
\end{itemize}

In chapter \ref{chpt:domSet} we will explore the dominating and the independent dominating games. To begin we  will formally define the dominating game. We will introduce upper and lower bounds for some classes of graphs. To bound these classes we will provide some explicit strategies for Alice. We will then extend the game to allow Alice and Bob to play more than once per turn. Finally, we will consider some bounds in the independent dominating game.

In chapter \ref{chpt:colouring} we will explore the colouring and marking games. We will begin with the standard colouring game. This game will then be extended to a version where Alice and Bob play more than once per turn. We will provide lower bounds for the colouring game. The marking game will then be introduced as a way to bound the colouring game. To do this we will uses the activation strategy. We will conclude with a look at the current best bound for the class of planer graphs.

%todo why is this iteresting, applications

%todo What this this report about

%todo where has this come from

%This work has many applications in computer science and operations research, including flight scheduling, bandwidth allocation and register allocation, as well as deep theoretical interest%note this is plagrisum
    
A directed graph is a graph in which each edge is assigned a direction. In such a graph the edges are no longer symmetric. That is, the edge $(a,b)$ is not the same as the edge $(b,a)$.
%todo picture
        
A note on notation. If $\CC$ is a class of graphs, and $\varphi_g(G)$ some property of a graph $G \in \CC$. Then $\varphi_g(\CC)$ is the smallest $k$ such that for every graph $H\in\CC$ $\varphi_g(H)\leq k$. A class $\CC$ is bounded above by $k$ if for every graph $H\in\CC$ $\varphi_g(H)\leq k$. $\CC$ is bounded below by $k$ if there is a graph $H$ in $\CC$ such that $\varphi_g(H)= k$. This can be thought of as Bob being allowed to pick the graph. If the game has a target score $t$ then Bob will win if $t < \varphi_g(G)$. So, if he is allowed to pick the graph he will pick a graph $G$ with $\varphi_g(G) > t$. Then if $t\geq \varphi_g(G)$ then it would not matter what graph Bob picks. Alice will always win. When considering a graph game we always consider it to be played by two player Alice and Bob.  

Finally, we introduce some game terms. In a game whenever Alice or Bob has there turn by choosing a vertex we call this a \textit{play}. For example in the colouring game a play when Alice chooses a vertex and assigns it a colour. A \textit{round} is a play of both Alice and Bob.  %todo terms and definations
   %todo class of graphs?


%todo add summery of results
    
%todo basic notation?
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    